# -*- coding: utf-8 -*-
"""Greeks

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MxNmxzGjkQQj3hKmrNsD5d4IKdXhSzcT
"""

from datetime import datetime as dt
from scipy import stats
from math import log, sqrt, exp
from scipy.optimize import fsolve

class european_option:

    def __init__(self, S0, K, t, M, r, sigma, d, CP, C=10):

        '''
        Attributes:
        ------------------------------------------------------------------------------------------
        S0 (initial underlying asset price),
        K (option strike price),
        t (pricing date),                  ## Can be input as datetime, string ('mm/dd/yyyy'), or years (float)
        M (maturity date),                 ## Same as t
        r (constant risk-free short rate), ## For 5%, enter 0.05
        sigma (volatility),                ## For 20%, enter 0.20
        d (continuous dividend yield),     ## For 2%, enter 0.02
        CP (call or put),                  ## Accepts 'Call'/'C' or 'Put'/'P' in any case
        C (market price of the option)     ## Optional - only used for implied vol calculation (default = 10)
        ------------------------------------------------------------------------------------------

        Methods:
        ------------------------------------------------------------------------------------------
        value()       - returns the present value of the option
        imp_vol()     - calculates implied volatility given market price
        delta()       - option delta
        gamma()       - option gamma
        vega()        - option vega
        theta()       - option theta
        rho()         - option rho
        ------------------------------------------------------------------------------------------
        '''

        self.S0 = S0
        self.K = K
        self.t = t
        self.M = M
        self.r = r
        self.sigma = sigma
        self.d = d
        self.CP = CP
        self.C = C
        self.refresh()

    def refresh(self):

        if type(self.t).__name__ == 'str':
            self.t= dt.strptime(self.t, '%m/%d/%Y')
        if type(self.M).__name__ == 'str':
            self.M = dt.strptime(self.M, '%m/%d/%Y')
        if self.CP.lower() in ['call', 'c']:
            self.CP = 'call'
        elif self.CP.lower() in ['put', 'p']:
            self.CP = 'put'
        else:
            raise ValueError("Check the value of CP variable - only 'Call'/'C' or 'Put'/'P' are allowed!")
        if self.t > self.M:
            raise ValueError("Pricing date is later than maturity date!")

        if type(self.t).__name__ in ['int', 'float']:
            self.T = self.M - self.t
        else:
            self.T = (self.M - self.t).days / 365.0


    def d1_d2(self):

        self.d1 = (log(self.S0 / self.K) + (self.r - self.d + 0.5 * self.sigma ** 2) * self.T) / (self.sigma * sqrt(self.T))
        self.d2 = self.d1 - self.sigma * sqrt(self.T)

    def value(self):

        self.refresh()
        self.d1_d2()

        if self.CP == 'call':
            value = (self.S0 * exp(-self.d * self.T) * stats.norm.cdf(self.d1, 0.0, 1.0)
                     - self.K * exp(-self.r * self.T) * stats.norm.cdf(self.d2, 0.0, 1.0))
        else:
            value = (self.K * exp(-self.r * self.T) * stats.norm.cdf(-self.d2, 0.0, 1.0)
                     - self.S0 * exp(-self.d * self.T) * stats.norm.cdf(-self.d1, 0.0, 1.0))
        return value

    def imp_vol(self):

        self.refresh()
        self.d1_d2()

        option = european_option(self.S0, self.K, self.t, self.M, self.r, self.sigma, self.d, self.CP, self.C)
        option.refresh()
        option.d1_d2()

        def difference(sig):
            option.sigma = sig
            return option.value() - option.C

        iv = fsolve(difference, option.sigma)[0]
        return iv

    def delta(self):

        self.refresh()
        self.d1_d2()

        if self.CP == 'call':
            delta = exp(-self.d * self.T) * stats.norm.cdf(self.d1, 0.0, 1.0)
        else:
            delta = exp(-self.d * self.T) * (stats.norm.cdf(self.d1, 0.0, 1.0) - 1)
        return delta

    def gamma(self):

        self.refresh()
        self.d1_d2()

        gamma = (exp(-self.d * self.T) * stats.norm.pdf(self.d1, 0.0, 1.0)) / (self.S0 * self.sigma * sqrt(self.T))
        return gamma

    def vega(self):

        self.refresh()
        self.d1_d2()

        vega = self.S0 * exp(-self.d * self.T) * stats.norm.pdf(self.d1, 0.0, 1.0) * sqrt(self.T)
        return vega

    def theta(self):

        self.refresh()
        self.d1_d2()

        if self.CP == 'call':
            theta = ( -(self.S0 * exp(-self.d * self.T) * stats.norm.pdf(self.d1, 0.0, 1.0) * self.sigma / (2 * sqrt(self.T)))
                      - (self.r * self.K * exp(-self.r * self.T) * stats.norm.cdf(self.d2, 0.0, 1.0))
                      + (self.d * self.S0 * exp(-self.d * self.T) * stats.norm.cdf(self.d1, 0.0, 1.0)) )
        else:
            theta = ( -(self.S0 * exp(-self.d * self.T) * stats.norm.pdf(self.d1, 0.0, 1.0) * self.sigma / (2 * sqrt(self.T)))
                      + (self.r * self.K * exp(-self.r * self.T) * stats.norm.cdf(-self.d2, 0.0, 1.0))
                      - (self.d * self.S0 * exp(-self.d * self.T) * stats.norm.cdf(-self.d1, 0.0, 1.0)) )
        return theta

    def rho(self):

        self.refresh()
        self.d1_d2()

        if self.CP == 'call':
            rho = self.K * self.T * exp(-self.r * self.T) * stats.norm.cdf(self.d2, 0.0, 1.0)
        else:
            rho = - self.K * self.T * exp(-self.r * self.T) * stats.norm.cdf(-self.d2, 0.0, 1.0)
        return rho

    def duration(self):

        self.refresh()
        original_value = self.value()
        print(f"Initial option value: {original_value}")

        self.T -= 10 / 365  # Reduce by one trading day (approx)
        new_value = self.value()
        print(f"Value after one day reduction: {new_value}")

        self.T += 10 / 365  # Restore initial time to maturity

        # Calculate daily change in value
        duration = (new_value - original_value) / (1 / 365)
        print(f"Calculated duration: {duration}")
        return duration
# Import the class (make sure the script is in the same directory or use a path)
# from <filename> import european_option

# Example configuration for a European Call option
call_option = european_option(
    S0=100,  # Initial price of the underlying asset
    K=105,   # Strike price
    t="12/01/2023",  # Evaluation date
    M="12/08/2024",  # Maturity date
    r=0.05,  # Risk-free rate (5%)
    sigma=0.2,  # Volatility (20%)
    d=0.02,  # Dividend yield (2%)
    CP='C'  # Call option
)

# Calculate the option value
print("Call option value:", call_option.value())

# Calculate the implied volatility
print("Implied volatility (Call option):", call_option.imp_vol())

# Greeks for the Call option
print("Delta (Call):", call_option.delta())
print("Gamma (Call):", call_option.gamma())
print("Vega (Call):", call_option.vega())
print("Theta (Call):", call_option.theta())
print("Rho (Call):", call_option.rho())

# Example configuration for a European Put option
put_option = european_option(
    S0=100,  # Initial price of the underlying asset
    K=95,    # Strike price
    t="12/01/2023",  # Evaluation date
    M="12/01/2024",  # Maturity date
    r=0.05,  # Risk-free rate (5%)
    sigma=0.2,  # Volatility (20%)
    d=0.02,  # Dividend yield (2%)
    CP='P'  # Put option
)

# Calculate the option value
print("Put option value:", put_option.value())

# Calculate the implied volatility
print("Implied volatility (Put option):", put_option.imp_vol())

# Greeks for the Put option
print("Delta (Put):", put_option.delta())
print("Gamma (Put):", put_option.gamma())
print("Vega (Put):", put_option.vega())
print("Theta (Put):", put_option.theta())
print("Rho (Put):", put_option.rho())

import numpy as np
import matplotlib.pyplot as plt

# Common parameters
K = 100       # Strike price
t = "12/01/2023"  # Evaluation date
M = "12/08/2024"  # Maturity date
r = 0.05      # Risk-free rate (5%)
sigma = 0.2   # Volatility (20%)
d = 0.02      # Dividend yield (2%)
CP = 'C'      # Call option

# Range of underlying asset prices
S0_range = np.linspace(50, 150, 100)  # From 50 to 150

# Containers for option values and Greeks
values = []
deltas = []
gammas = []
vegas = []
thetas = []
rhos = []

for S0 in S0_range:
    option = european_option(S0, K, t, M, r, sigma, d, CP)
    values.append(option.value())
    deltas.append(option.delta())
    gammas.append(option.gamma())
    vegas.append(option.vega())
    thetas.append(option.theta())
    rhos.append(option.rho())

# Plot option value
plt.figure(figsize=(10, 6))
plt.plot(S0_range, values, label="Option Value (Call)", color="blue")
plt.title("Option Value vs Underlying Price S0")
plt.xlabel("Underlying Asset Price S0")
plt.ylabel("Option Value")
plt.legend()
plt.grid()
plt.show()

# Plot Greeks
plt.figure(figsize=(10, 8))

# Delta
plt.subplot(2, 3, 1)
plt.plot(S0_range, deltas, label="Delta", color="red")
plt.title("Delta")
plt.grid()

# Gamma
plt.subplot(2, 3, 2)
plt.plot(S0_range, gammas, label="Gamma", color="green")
plt.title("Gamma")
plt.grid()

# Vega
plt.subplot(2, 3, 3)
plt.plot(S0_range, vegas, label="Vega", color="orange")
plt.title("Vega")
plt.grid()

# Theta
plt.subplot(2, 3, 4)
plt.plot(S0_range, thetas, label="Theta", color="purple")
plt.title("Theta")
plt.grid()

# Rho
plt.subplot(2, 3, 5)
plt.plot(S0_range, rhos, label="Rho", color="brown")
plt.title("Rho")
plt.grid()

plt.tight_layout()
plt.show()